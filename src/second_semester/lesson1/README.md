# Занятие №1 18.02.2025
## Правила игры на второй семестр

### Основная информация
- **Количество занятий:** 12 лекций и 8 практических занятий.
- **Форма контроля:** экзамен.
- **Возможность получения автомата:** да, при соблюдении следующих условий:
  - **Все** лабораторные работы сданы (допускается просрочка сдачи не более двух раз).
  - **Не более** 2 пропусков лекций.
  - Превышение лимита пропусков возможно только по уважительной причине с обязательным подтверждением.

### Организация репозитория с лабораторными
> Осваиваем работу с Git. \
> P.S. Я понимаю, что это напрямую не связано с предметом. 
> Однако, поскольку вы все потенциальные специалисты ИТ-сферы, эти навыки будут вам полезны.

Все лабораторные работы должны быть размещены в одном репозитории.

Репозиторий должен быть организован в виде древовидной структуры.
В корневой директории должен находиться файл-визитка — README.md, содержащий ваше ФИО и номер группы (включая подгруппу).
Каждая лабораторная работа должна располагаться в отдельной папке/директории, название которой соответствует названию лабораторной.
Названия классов должны быть осмысленными и отражать их содержание в соответствии с заданием.

> Если вы испытываете сложности с неймингом, настоятельно рекомендую ознакомиться со второй главой книги "Чистый код" Роберта Мартина.

Лабораторные работы должны добавляться в основную ветку репозитория через pull request.
Что это такое?
Это запрос на объединение изменений из одной ветки в другую.
В рамках такого запроса можно настроить множество параметров, но для нас важно удобство обсуждения кода и утверждения предлагаемых изменений.

> Объясню зачем. \
> Во-первых, это полезная штука. Во всех приличных проектах изменения вносятся через pull request'ы. 
> Это позволяет удобно и наглядно обсуждать изменения, связывая обсуждение непосредственно с кодом.  
> Во-вторых, это упрощает отслеживание прогресса выполнения лабораторных. Нет открытых реквестов — нет долгов.   
> В-третьих, мой тг скажет мне спасибо, так же как и ваш — скажет спасибо вам.

#### Гайд по созданию pull / merge request'a:
1. Выполните лабораторную работу.
2. Создайте новую ветку с названием, соответствующим лабораторной работе.
3. Переключитесь на созданную ветку.
4. Сделайте коммит и отправьте изменения в репозиторий на GitHub.
5. Перейдите в свой репозиторий на GitHub и откройте вкладку **Pull Requests**.
6. Нажмите на кнопку `New pull request`.
7. Выберите ветку, в которую будут вливаться изменения (обычно это основная ветка, например, `main` или `master`), и ветку, из которой берутся изменения (ваша новая ветка).
8. Создайте pull request. По желанию добавьте описание, связанное с выполненной лабораторной работой.

![create_pull_request.png](_images/create_pull_request.png)

9. Отправьте мне ссылку на pull request в Telegram. Если вы добавите меня в качестве ревьюера, я получу уведомление на почту, и писать в Telegram не обязательно.

![pull_request.png](_images/pull_request.png)

После этого мы обсуждаем спорные моменты (если таковые имеются) непосредственно в pull request'е, используя комментарии.

> Не затягивайте с лабораторным, не провоцируйте `merge conflict'ы`, разбирать их крайне неприятно.

---
## Двоичные деревья

#### Что такое двоичное дерево?

Прежде чем браться за тему, необходимо разобраться в том, что же называется деревом.
Дерево состоит из узлов, соединенных ребрами. В таком представлении дерева узлы обозначаются кружками, а ребра — линиями, соединяющими кружки.
Деревья как абстрактная математическая категория были достаточно подробно изучены. 
В действительности дерево является частным случаем более общей структуры, называемой графом.

![tree.png](_images/tree.png)

В программах узлы часто представляют сущности: людей, детали машин, забронированные авиабилеты и т. д., то есть типичные элементы, сохраняемые в любых
структурах данных. В ООП-языках, к числу которых относится Java, сущности
реального мира представляются в виде объектов.

Существует несколько разновидностей деревьев.
Но в данный момент нас интересует двоичное дерево.
Особенностью двоичного дерева является то, что каждый узел двоичного
дерева имеет не более двух потомков.

![binary_tree.png](_images/binary_tree.png)

#### Для чего нужны двоичные деревья?

Обычно двоичное дерево сочетает в себе преимущества двух других структур: упорядоченного массива и связанного списка. 
Поиск в дереве выполняется так же быстро, как в упорядоченном массиве, а операции вставки и удаления элементов так же быстро, как в связанном списке.

Представьте упорядоченный массив, где все элементы отсортированы. 
Такой массив позволяет быстро находить элементы с помощью двоичного поиска: алгоритм проверяет середину массива и, в зависимости от результата, продолжает поиск в верхней или нижней половине. Это обеспечивает время поиска O(log N). 
Также упорядоченный массив поддерживает быстрый перебор элементов в отсортированном порядке.

Однако вставка и удаление элементов в таком массиве требуют значительных затрат времени:
- Для вставки нужно найти позицию для нового элемента и сдвинуть все большие элементы, чтобы освободить место. В среднем это требует сдвига N/2 элементов.
- Удаление также требует сдвига элементов для заполнения пустого места.

Таким образом, если в вашей задаче часто выполняются операции вставки и удаления, упорядоченный массив будет неэффективным выбором.

Напротив, в связных списках операции вставки и удаления выполняются быстро — достаточно изменить несколько ссылок, что занимает время O(1). 
Однако поиск элемента в связном списке неэффективен: алгоритм вынужден последовательно перебирать элементы от начала списка, пока не найдет нужный, что в среднем требует N/2 сравнений и выполняется за время O(N).

Даже если использовать упорядоченный связный список, это не ускорит поиск произвольного элемента, так как для доступа к любому узлу необходимо пройти всю цепочку ссылок с начала. 
Хотя перебор элементов в упорядоченном списке выполняется быстрее, чем в неупорядоченном, это не помогает в поиске конкретного элемента.

Деревья объединяют в себе плюсы вышеописанных структур данных.

Основные термины:
- **Корень**: Начальный узел дерева, от которого начинаются все остальные узлы.
- **Родительский узел**: Любой узел (кроме корневого) имеет ровно одно ребро, уходящее вверх к другому
  узлу. Узел, расположенный выше него, называется родительским узлом (или просто
  родителем) по отношению к данному узлу.
- **Дочерний узел**: Любой узел может иметь одно или несколько ребер, соединяющих его с узлами
  более низкого уровня. Такие узлы, находящиеся ниже заданного узла, называются
  его потомками.
- **Лист**: Узел, не имеющий дочерних элементов.
- **Поддерево**: Любой узел может рассматриваться как корень поддерева, состоящего из его потомков, потомков его потомков и т. д.
- **Посещение**: Переход программы к узлу (обычно с целью выполнения некоторой операции,
  например проверки значения одного из полей данных или вывода) называется
  посещением.
- **Обход**: Обходом дерева называется посещение всех его узлов в некотором заданном порядке. Например, все узлы дерева могут перебираться в порядке возрастания ключей.
- **Уровень**: Уровнем узла называется количество поколений, отделяющих его от корня. Если
  считать, что корень находится на уровне 0, то его потомки находятся на уровне 1,
  потомки потомков — на уровне 2 и т. д.
